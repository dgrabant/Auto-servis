// 🔹 Uvoz svih potrebnih modula i funkcija iz vanjskih JS datoteka i biblioteka
import * as THREE from '/node_modules/three'; // Glavna Three.js biblioteka
import { LoadGLTFByPath, LoadCameraPath, LoadSvjetlaPath } from '../called/modelLoader.js'; // Funkcija za učitavanje .gltf modela
import { setupRenderer } from '../called/rendererSetup.js'; // Funkcija za postavljanje renderera
import { spawnMultipleModels, justLogedIn, justLogedOut } from '../called/spawn_menu.js'; // Funkcija za stvaranje korisničkog izbornika (UI)
import { getFirstObjectHit, cameraNext, cameraPrev, clickTransition, returnToPrevCam } from '../called/controls.js'; // Funkcije za kontrole kamere i interakciju
import { getFirstCameraInScene, updateCameraAspect } from '../called/cameraSetup.js'; // Funkcije za rad s kamerama u sceni
import { OrbitControls } from '/node_modules/three/examples/jsm/controls/OrbitControls.js'; // Three.js kontroler za orbitiranje kamerom
import { cleanMemory } from '../called/garbageClean.js';
//import { gsap } from '/node_modules/gsap'; // Biblioteka za animacije (nije obavezno korištena u ovom kodu)
import { checkIfLogedIn } from '../called/loginCheck.js';
//import { useThree } from '@react-three/fiber'
//import { useEffect } from 'react'

window.addEventListener('load', () => {
  cleanMemory();
  console.log('Scena očišćena — spremna za nove modele!');
});



//Putanje do modela i teksture
const scenePath = 'src/assets/models/audi_scena1.glb'; // Putanja do .gltf 3D scene
const texturePath = 'src/assets/textures/background.jpg'; // Putanja do panoramske pozadinske teksture (HDRI)
const cameraPath = 'src/assets/models/kamere.gltf';
const svjetlaPath = 'src/assets/models/svjetla.gltf';

const djeloviHTML = document.getElementById("djelovi");

let renderer = new THREE.WebGLRenderer({

	//Defines the canvas component in the DOM that will be used
	canvas: document.querySelector('#bg'),
		antialias: true,
	});

// 🔹 Kreiranje nove Three.js scene
const scene = new THREE.Scene();

// 🔹 Lista svih kamera u sceni i varijabla aktivne kamere
let cameraList = [];
let activeCamera;

// 🔹 Postavljanje renderera
renderer = setupRenderer(scene, renderer); // Funkcija koja kreira i konfigurira WebGLRenderer
renderer.setSize(window.innerWidth, window.innerHeight); // Prilagođava renderer dimenzijama prozora
document.body.appendChild(renderer.domElement); // Dodaje canvas renderer-a u HTML dokument

// 🔹 Dodavanje svjetla u scenu
const hemiLight = new THREE.HemisphereLight(0x00527a, 0xffaa00, 0); 
// HemisphereLight stvara ambijentalno svjetlo odozgo (nebo) i odozdo (zemlja)
// Ovjde je intenzitet 0, što znači da je svjetlo trenutno isključeno
scene.add(hemiLight);

// 🔹 Učitavanje .gltf scene (asinhrono)
await LoadGLTFByPath(scene, scenePath)
  .then(() => {
    
  })
  .catch((error) => console.error('Error loading JSON scene:', error)); // Ako dođe do pogreške, ispiši ju

  await LoadSvjetlaPath(scene, svjetlaPath)
  .then(() => {
    
  })
  .catch((error) => console.error('Error loading JSON scene:', error)); // Ako dođe do pogreške, ispiši ju

  await LoadCameraPath(scene, cameraPath)
  .then(() => {
    // Kad se model uspješno učita:
    cameraList = getFirstCameraInScene(scene); // Dohvati sve kamere iz scene
    activeCamera = cameraList[0]; // Postavi prvu kameru kao aktivnu
    updateCameraAspect(activeCamera); // Ažuriraj aspect ratio kamere (da se prilagodi ekranu)
    initCameraSystem(); // Pokreni sustav kamera i kontrole
    
  })
  .catch((error) => console.error('Error loading JSON scene:', error)); // Ako dođe do pogreške, ispiši ju


  let interactableModels = [];

  await spawnMultipleModels(scene, checkIfLogedIn()).then(models => {
    interactableModels = models;
})
  .catch((error) => console.error('Error loading JSON scene:', error)); // Ako dođe do pogreške, ispiši ju
  console.log("Interactable objects: ",interactableModels);
  // Ažuriraj renderer i kamere kad se promijeni veličina prozora
  function onWindowResize() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateCameraAspect(activeCamera);
  }

// 🔹 Učitavanje HDRI pozadine i refleksije
const loader = new THREE.TextureLoader();
let isLoaded = false;
loader.load(
  texturePath, // Putanja do slike
  (texture) => { // Callback kad je tekstura uspješno učitana
    
    texture.mapping = THREE.EquirectangularReflectionMapping; // Mapa refleksije za HDRI (360°)
    texture.colorSpace = THREE.SRGBColorSpace; // Korekcija boja za ispravno prikazivanje

    // PMREMGenerator konvertira HDRI teksturu u format pogodan za realistične refleksije
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    // Stvori environment mapu iz HDRI teksture
    const envMap = pmremGenerator.fromEquirectangular(texture).texture;

    // Postavi pozadinu i environment refleksije u sceni
    scene.background = envMap;
    scene.environment = envMap;

    // Oslobodi memoriju (teksture se više ne koriste izravno)
    texture.dispose();
    pmremGenerator.dispose();

    console.log("Pozadina i refleksije su uspješno postavljene!");
    setTimeout(() => {
      activeCamera=cameraList[1];
      onWindowResize();
      
      
      setTimeout(() => {
      console.log("Pokrećem prijelaz na kameru 5...");
      transitionCamera(activeCamera, cameraList[6], 1500); // Glatki prijelaz kamere
      
      setTimeout(() => {
        isLoaded =true;
      },1500);


    }, 1500);


    }, 1500);
    
  },
  undefined, // Callback tijekom učitavanja (nije potreban)
  (err) => console.error("Greška pri učitavanju teksture:", err) // Ako se tekstura ne učita
);


const main = document.querySelector('main');
const isFirst = main === document.body.firstElementChild;
console.log(isFirst ? 'MAIN je prvi u body-ju' : 'MAIN NIJE prvi u body-ju');



// ======================================================
// 🔹 FUNKCIJA ZA POSTAVLJANJE SUSTAVA KAMERA I KONTROLA
// ======================================================
function initCameraSystem() {
  let cameraPosition = 6; // Početna kamera (indeks u listi kamera)
  let cameraPositionPrev; // Zadnja kamera (radi lakšeg prelaska unazad)

  // 🔸 Kreiraj orbit kameru (dodatna, ručna kamera)
  const cameraOrbit = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cameraOrbit.position.copy(activeCamera.position); // Postavi ju na istu poziciju kao aktivna kamera

  // 🔸 Dodaj orbit kontrole
  const controls = new OrbitControls(cameraOrbit, renderer.domElement);
  controls.enabled = false; // Isključeno dok ne odlučiš omogućiti orbit kontrolu
  
  
  
  
  let firstHitName;
  // 🔸 Klik mišem — interakcija s objektima u sceni
  document.addEventListener('click', () => {
    if (cameraPosition != 3) {
      firstHitName = getFirstObjectHit(window, activeCamera, scene, 7);
    console.log(firstHitName);
    cameraPosition = clickTransition(cameraPosition,firstHitName);
    console.log(cameraPosition, activeCamera, cameraList[cameraPosition]);
    if (cameraPosition == 2) {
      transitionCamera(activeCamera, cameraList[cameraPosition], 3000);
    }
    else{
    transitionCamera(activeCamera, cameraList[cameraPosition], 1500);
    }
    setTimeout(() => {
      if (cameraPosition == 3) {
      if (djeloviHTML.classList.contains('hidden')) {
            // 1. Remove the 'hidden' class (sets opacity: 0 to opacity: 1 after transition)
            djeloviHTML.classList.remove('hidden');
            // 2. Add the 'visible' class (optional, but good for clarity)
            djeloviHTML.classList.add('visible'); 
        } else {
            // Optional: Add logic to fade it back out if it's already visible
            djeloviHTML.classList.remove('visible');
            djeloviHTML.classList.add('hidden');
        }
      }
    }, 1500);
    
    }
    
    // Funkcija vjerojatno pronalazi i označava prvi objekt s određenim imenom
  });

  // 🔸 Scroll kotačić miša — promjena kamere unaprijed / unazad
  window.addEventListener('wheel', (event) => {
    if (cameraPosition < cameraList.length && cameraPosition >= (cameraList.length - 3) && isLoaded) {
      if (event.deltaY < 0) { // Scroll prema dolje → iduća kamera
      cameraPositionPrev = cameraPosition;
      cameraPosition = cameraPrev(cameraList, cameraPosition); // Dohvati prethodnu kameru
      transitionCamera(activeCamera, cameraList[cameraPosition], 1500); // Glatki prijelaz
    } else { // Scroll prema gore → prethodna kamera
      cameraPositionPrev = cameraPosition;
      cameraPosition = cameraNext(cameraList, cameraPosition);
      transitionCamera(activeCamera, cameraList[cameraPosition], 1500);
    }
    }
    
  });



  document.addEventListener('keydown', function(event) {
  if (event.key === "Escape" || event.key === "Esc") {
    // Close your modal window or perform any desired action
    console.log("esc");
    cameraPosition = returnToPrevCam(cameraPosition);
    if (cameraPosition == 6) {
      if (djeloviHTML.classList.contains('hidden')) {
            // 1. Remove the 'hidden' class (sets opacity: 0 to opacity: 1 after transition)
            djeloviHTML.classList.remove('hidden');
            // 2. Add the 'visible' class (optional, but good for clarity)
            djeloviHTML.classList.add('visible'); 
        } else {
            // Optional: Add logic to fade it back out if it's already visible
            djeloviHTML.classList.remove('visible');
            djeloviHTML.classList.add('hidden');
        }
      }
      if (cameraPosition == 4) {
        setTimeout(() => {
        transitionCamera(activeCamera, cameraList[cameraPosition], 3000);
      }, 1000);
      }
      else
      setTimeout(() => {
        transitionCamera(activeCamera, cameraList[cameraPosition], 1500);
      }, 1000);

  }
});




  // ======================================================
  // 🔹 MOBILNA PODRŠKA – GESTE ZA PREBACIVANJE KAMERA
  // ======================================================
 let touchStartX = 0;
let touchEndX = 0;
let touchStartTime = 0;

window.addEventListener('touchstart', (e) => {
  if (e.touches.length > 1) return; // ignoriraj multi-touch
  touchStartX = e.touches[0].clientX;
  touchStartTime = Date.now(); // vrijeme početka
}, { passive: true });

window.addEventListener('touchmove', (e) => {
  if (e.touches.length > 1) return;
  touchEndX = e.touches[0].clientX;
}, { passive: true });

window.addEventListener('touchend', (e) => {
  const deltaX = touchStartX - touchEndX;
  const elapsed = Date.now() - touchStartTime;

  // Uvjeti za stvarni swipe:
  //  - potez duži od 80px
  //  - trajanje između 100 i 600 ms (izbjegava tap i sporo vučenje)
  if (Math.abs(deltaX) > 80 && elapsed > 100 && elapsed < 600) {
    const direction = deltaX > 0 ? 1 : -1; // lijevo = 1, desno = -1
    const wheelEvent = new WheelEvent('wheel', { deltaY: direction });
    window.dispatchEvent(wheelEvent);
  }
});


  // 🔹 Reakcija na promjenu veličine prozora
  window.addEventListener('resize', onWindowResize, false);
  onWindowResize(); // Pozovi odmah da se inicijalno sve prilagodi

  animate();

  // ======================================================
  // 🔹 POMOĆNE FUNKCIJE
  // ======================================================

  

  // Glavna petlja renderiranja — prikazuje scenu kontinuirano
  function animate() {
    requestAnimationFrame(animate); // Ponavljaj svaki frame
    

    renderer.render(scene, activeCamera); // Renderiraj iz perspektive aktivne kamere
  }
}

// ======================================================
// 🔹 FUNKCIJA ZA GLATKI PRIJELAZ IZMEĐU DVIJE KAMERE
// ======================================================
function transitionCamera(fromCam, toCam, duration = 1000) {
  if (!fromCam || !toCam) {
    console.warn("Jedna od kamera nije definirana!");
    return;
  }

  // 🔸 Početna i završna pozicija i orijentacija
  const startPos = fromCam.position.clone();
  const startQuat = fromCam.quaternion.clone();
  const endPos = toCam.position.clone();
  const endQuat = toCam.quaternion.clone();

  const startTime = performance.now();

  // 🔸 Ručno animiranje pozicije i rotacije tijekom zadanog vremena
  function animate2() {
    const elapsed = performance.now() - startTime;
    const t = Math.min(elapsed / duration, 1); // Normalizirano vrijeme (0 → 1)

    // Interpolacija pozicije i orijentacije
    activeCamera.position.lerpVectors(startPos, endPos, t);
    activeCamera.quaternion.slerpQuaternions(startQuat, endQuat, t);

    renderer.render(scene, activeCamera); // Renderiraj scenu tijekom prijelaza

    if (t < 1) requestAnimationFrame(animate2); // Nastavi dok prijelaz nije gotov
  }

  animate2(); // Pokreni animaciju prijelaza
}

// ======================================================
// 🔹 UI IZBORNIK
// ======================================================

document.addEventListener('keydown', function(event) {
  if (event.key === "e" || event.key === "E") {
    justLogedIn(scene);
  }
});
document.addEventListener('keydown', function(event) {
  if (event.key === "q" || event.key === "Q") {
    justLogedOut(scene);
  }
});


let mouseInside = false;

window.addEventListener('mouseenter', () => {
  mouseInside = true;
  console.log('Miš je na stranici');
});

window.addEventListener('mouseleave', () => {
  mouseInside = false;
  console.log('Miš je napustio stranicu');
});


